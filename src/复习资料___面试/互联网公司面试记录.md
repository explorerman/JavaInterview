## 某小公司技术有限公司

1. hashcode相关，为什么要重写hashcode，怎么重写

2. **只重写一个都会导致出现重复,无法覆盖**

   **new一个相等意义的对象get不到**

3. ```java
   public class testStringEqualHashCode {
       public static void main(String[] args) {
           HashMap<String, String> map = new HashMap<>();
           String st1 = new String("fo");
           String st2 = new String("fo");
           map.put(st1, "fo1");
           map.put(st2, "fo2");
           System.out.println(map.size());
           System.out.println(map.get(st1));
           System.out.println(map.get(st2));
   
       }
   }
   输出：
    1
   fo2
   fo2
   ```

   使用String时，因为重写了hashcode和equal方法，所以被判断为同一个对象

   hashcode是根据字符串算出来的，equal是比较的内存地址。

   ##### 只重写了equals没有重写hashcode

   ```java
   import java.util.HashMap;
   import java.util.Map;
   
   public class OnlyEquals {
       public static class String3 {
   
           private String value;
   
   
           public String3(String value) {
               this.value = value;
   
           }
   
           @Override
           public boolean equals(Object obj) {
               if (obj == null) {
                   return false;
               }
               if (this == obj) {
                   return true;
               }
               if (obj instanceof String3) {
                   String3 o = (String3) obj;
                   return this.value.equals(o.value);
               }
               return false;
   
           }
       }
   
       public static void main(String[] args) {
           Map<String3, String> map = new HashMap<String3, String>();
           String3 str1 = new String3("fo");
           String3 str2 = new String3("fo");
           map.put(str1, "fo1");
           map.put(str2, "fo2");
           System.out.println(map.size());
           System.out.println(map.get(str1));
           System.out.println(map.get(str2));
           String3 str3 = new String3("fo");
           System.out.println(map.get(str3));
       }
   }
   输出
     2
   fo1
   fo2
   null
   ```

   **因为就算“相等”,但是hash不同,导致分布在不同的数组项.**

   **其实就是不相等.因为在 Map 和 Set 类集合中，用到这两个方法时，首先判断 hashCode 的值，如果 hash 相等，则再判断 equals 的结果**.

   **去用一个“相等”的对象get,肯定是null.**

   ##### 只重写了hashcode没有重写equals

   我们知道`String`类重写了hashcode方法.

   String的hashCode方法实现如下， 计算方法是 `s[0]*31^(n-1) + s[1]*31^(n-2) + … + s[n-1]`，其中`s[0]`表示字符串的第一个字符，n表示字符串长度：

   ```
   public int hashCode() {
       int h = hash;
       if (h == 0 && value.length > 0) {
           char val[] = value;
   
           for (int i = 0; i < value.length; i++) {
               h = 31 * h + val[i];
           }
           hash = h;
       }
       return h;
   }
   ```

   比如”fo”的hashCode = `102 *31^1 + 111` = 3273， “foo”的hashCode = 102* 31^2 + 111 * 31^1 + 111 = 101574 

   > 'f'的ascii码为102, 'o'的ascii码为111)

   ```java
   import java.util.HashMap;
   import java.util.Map;
   
   public class OnlyHashCode {
       public static class String2 {
   
           private String value;
   
           public String2(String name) {
               this.value = name;
           }
   
           @Override
           public int hashCode() {
               return value.hashCode();
           }
       }
       public static void main(String[] args) {
           Map<String2, String> map = new HashMap<String2, String>();
           String2 str1 = new String2("fo");
           String2 str2 = new String2("fo");
           map.put(str1, "fo1");
           map.put(str2, "fo2");
           System.out.println(map.size());
           System.out.println(map.get(str1));
           System.out.println(map.get(str2));
           String2 str3 = new String2("fo");
           System.out.println(map.get(str3));
       }
   }
   ```

   2
   fo1
   fo2
   null

   **这样的实现,实际也不存在相等的对象,因为equals比较的都是内存地址.**

   上面这段代码中，map中有2个元素str1和str2。但是这2个元素是在哈希表中的同一个数组项中，也就是在同一串链表中。 但是为什么stu1和stu2的hashCode相同，但是两条元素都插到map里了，这是因为map判断重复数据的条件是 **两个对象的哈希码相同并且(两个对象是同一个对象或者两个对象相等[equals为true])**。 所以再给Student重写equals方法，并且只比较name的话，这样map就只有1个元素了。

4. 编码相关:全国人民的身份证存入一个文件，估算一下多大容量，思路：从编码utf-8等角度

   一个数字占一字节，身份证按20位算是20个字节，10e人 * 20个字节 / 1000 /1000/ 1000 大约是20G
   
3. 怎么对20e数字进行排序：外排序，参考B+进行页内有序，页间有序。外排序过程
4. js怎么算页面渲染时间

## 偶数科技

### 1面

算法题：

1. 二叉树的最大深度
2. 字符串的异位词
3. 跳跃游戏

B+树，docker命令

#### 2面

算法题：

1. 递归求n的阶乘

软件架构层面设计:数据库主备，缓存（mem,redis,浏览器缓存，本地缓存等），MVC，分库分表

前端传到后台的字符串sql，用逗号切分，如果where中有逗号呢？如何操作？---正则表达式

叙述项目的来龙去脉，技术选型等如何操作

怎么定位异常代码？CPU很高，内存一般时，可能出现的问题，如何定位？OOM相关

并发，吞吐量？如何提高并发，吞吐量？

如果页面很慢，如何定位是前端慢还是后端慢？

jvm调优，Tomcat调优

英文阅读源码能力？

国产机与win的区别，平时开发有啥坑？

如何查找资料

## 58一面

1.B+树和B树的区别

2.索引，怎么命中，为什么没有命中

3.hashmap,hash怎么做的，为什么是2的n次，多会变成红黑树，多会退化为链表

4.hashmap，concurrenthashmap

5.硬币找零

6.斐波那契数列

7.6条跑道，36匹马，找前三

8.高可用，Redis6的新特性，缓冲，击穿，失效等

9.多级缓存

## 爱学习一面

1. 线程池相关，参数，队列，拒绝策略
2. 并发包，常用的这些并发包,threadlocal
3. hashmap,concurrenthashmap等
4. 分布式锁：set，red lock， 幂等性
5. 数据库隔离级别，锁，索引
6. jvm内存分布:堆，栈等
7. 垃圾收集器cms,g1
8. 算法题：非递归中序遍历

### 爱学习二面

1. 什么时候有行锁？ 走索引的时候
2. 线程池的过程
3. 算法题：大数相加 白板写

## 蚂蚁金服

1. 算法题：旋转矩阵

## 新华三 一面

mq相关，至少了解大概，目的，常用的实现

concurrenthashmap细看，还是不太熟

线程池

cas

Nginx

redis持久化相关