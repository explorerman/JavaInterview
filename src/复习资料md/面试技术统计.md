# java

1.hashmap相关

hashmap1.7和1.8比较大的一个改变是结构的改变，1.7是数组+链表，也就是拉链式的方法实现的，数据节点是一个内部类entry<k,v>节点，数据插入的过程是头插法，头插法在resize扩容的过程，在两个线程同时调用transfer的时候，把里面的entry进行rehash，在这个过程可能会形成环，在下一次get的时候，形成死循环，也可能没有加锁，他的数据不保证是线程安全的，可能push进去的值，取出来还是我push进去的一个值。

jdk1.8之后，做了比较大的改变，链表+数组+红黑树，把entry节点也变成了node节点，他的整个put也做了一个优化

扩容机制：capacity在初始化的时候默认是16，负载因子0.75，threshold = capacity * 0.75。

hashtable是方法上加synchronized

concurrenthashmap只会锁住segment（1.8实现不用segment）那段，不会影响别的，所以并发性更高

加锁的时候，使用cas和synchronized的一个升级

无锁->偏向锁->轻量级锁（乐观锁）自旋多次->重量级锁

[如何确定hashmap的容量](https://blog.csdn.net/sybnfkn040601/article/details/73194613/)

2.锁相关

valatile：

线程对变量的所有操作（读取，赋值）都是在工作内存中进行的，不能直接操作主内存中的变量，volatile也一样，但由于它特殊的操作顺序性规定，看起来就像是直接在主内存中读写访问一般。

当一个变量被定义为volatile时 ，它将具备两种特性：**第一是保证该变量在所有的线程可见**。可见性是指:当一条线程修改了这个变量的值后，新值对于其他线程来说是可以立即得知的，普通变量不行，普通变量需要通过主内存来完成。

volatile变量在各个线程的工作内存中不存在一致性问题（在各个线程的工作内存中，volatile也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题）

主内存，工作内存之间的操作是原子的，但Java的语句和运算并不一定是原子的，所以在并发情况下也是不安全的

volatile的使用场景：

1. 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
2. 变量不需要与其他的状态共同参与不变约束。

volatile的第二个语义是禁止指令重排优化，线程内串行，线程间并行。

相当于内存屏障（重排序时不能把后面的指令重排序到内存屏障之前的位置）

z

1. b

# MySQL

多个索引匹配的时候：

在创建索引的时候考虑：覆盖索引，覆盖索引可以减少回表的次数，MySQL5.6之后对覆盖索引做了进一步优化，支持索引下推的功能，把覆盖索引所覆盖的一个字段，进一步的进行筛选，尽量减少回表的次数，可以在explain中看执行计划，在extra字段里面有using index condition。

如果我们的存储介质是机械硬盘的话，机械硬盘比较怕随机读写，因为有一个磁盘寻址的开销，我们可以把mrr打开，就是multi range read,他可以在回表之前把id读到buffer里面，进行一个排序，把原来的随机操作变成一个顺序操作，这是覆盖索引可以做的一些优化，覆盖索引也可以避免，比如说排序用到的一些临时文件，可以利用最左原则和覆盖索引配合，减少一些索引的维护。

对一些普通索引，写多读少的服务，并且这些服务唯一性要求没有那么高，或者业务代码可以保证唯一性的时候，可以用普通索引，普通索引可以用到change buffer ,它可以把一些写操作缓存下来，在我们读的时候，进行merge的操作，这样可以提高写入的速度，还有内存的命中率。

这是在创建索引的时候可以考虑的一些点。

如果索引走不上，该思考：索引失效的情况，sql写的有问题，比如对索引字段有些函数操作，或者就是在连接查询的时候，两个表的编码不一样，有没有可能字段的类型不一样，如果说string赋给他一个id,如果string和id比较的话，我们会把string转成id,用到了一个隐式的cast的函数进行转化。

索引统计信息有问题，就是analyze table重新统计索引，因为索引信息并不是一个准确值，它是一个随机采样的过程，可能会出现问题，还有可能是业务表增加太多，内存的一个空洞比较多，都有可能造成索引选择的一个问题。

explain分析出来的索引是最优的吗，显然不是，执行计划只是MySQL自己在开始执行前分析出来的一个执行计划，我们在索引的时候，可能会有回表操作，还有排序操作，可能会走错。

索引有时候走的不好，反而导致性能更差，这时候可以考虑使用force index强制走一个索引，但是不太好，作为项目的一个应急预案，因为他可能迁到别的一个数据库就不支持了，还需要做一个代码的重新发布。另一种就是考虑使用覆盖索引+最左原则，能不能把这个选错的索引删除。挺常用的。

# http相关