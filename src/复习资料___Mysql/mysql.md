

## InnoDB的buffer poll

buffer poll为了解决从磁盘读写慢，使用buffer poll在内存中申请了一块连续的空间作为缓存



[mysql5.6升级到5.7](https://blog.csdn.net/u010010725/article/details/70170231)

1. 索引

## 表结构设计

三范式：

1.  1NF是对属性的原子性约束，要求属性具有原子性，不可再分解； 
2.  2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性； 
3.  3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。 

范式化设计优缺点:

**优点:**

可以尽量得减少数据冗余，使得更新快，体积小

缺点:对于查询需要多个表进行关联，减少写得效率增加读得效率，更难进行索引优化

**反范式化:**

优点:可以减少表得关联，可以更好得进行索引优化

缺点:数据冗余以及数据异常，数据得修改需要更多的成本

重构oa项目表结构设计：取号加了乐观锁（以前业务有重号的问题），

1. 基本原则：根据业务灵活拆分：dm表，cs表，业务表单：将所有的表单进行拆分。

重构交换表结构做的两件事：

1. 业务表的拆分，根据范式和业务进行调整，以前的业务表冗余性要不很大，要不很小，我做的改进：业务表基本由三部分构成：表单数据，表单关联项（正文，附件，意见等，都存主键），流程设置

2. 根据业务场景合适的加索引：

1. 场景1：打开一个文，where条件第一个都是主键，所以不需要加索引，直接走聚簇索引。
2. 场景2：查询已发送公文的列表：where条件一般为当前登录人，链表一般只需要展示文的名称，环节，接收单位等，所以建了联合索引。涉及的多表在业务中做关联。

业务表：存三部分：表单数据，正文/附件id,意见类（意见，备注等）配置（打开标准，删除标准，操作人id，时间）


## sql优化

两个重构项目做的优化：表结构调整（都设为非空，控制字段长度），索引，代码层面都改为单表，代码中合并数据。

怎么确定索引优化成功了（sql的执行时间怎么算），怎么查看慢查询

范式，索引（B+树）得熟

隔离级别，ACID事务等次之

redo,undo日志。

[ 向mysql插入100w条数据，存储过程 ](https://cloud.tencent.com/developer/article/1534007)

[mysql使用存储过程插入千万级数据如何提升效率](https://blog.csdn.net/youcheng_ge/article/details/77728189)

[mysql中为什么不要使用存储过程](https://blog.csdn.net/aoerqileng/article/details/79731713)

数据库层面做了哪些优化：

1.优化表结构：都设为非空（为什么），固定字段长度（为什么），去除一些没必要的冗余数据

在行数据中，一条记录存储的是记录的真实数据和额外信息（**变长字段长度列表**（逆序存放），**NULL值列表**（逆序），记录头信息）

为什么设置为非null，一是因为可以少一个bit位，二是如果有null值，走索引的话，最多是ref的访问方法。

varchar（最长存65535）,blob,text都是变长字段列表，当设置为定长时，不会放到变长字段列表，设置为非空时，则没有NULL值列表

2.索引方面：displayName = '分发' and deleteFlag = '2' and actor = 'uuid(5)'

加联合索引（联合索引的顺序很重要，最左前缀，<span style="color:red">只要页面和记录是排好序的，我们就可以通过二分法来快速定位查找</span>）

优化时调整索引顺序，顺序很重要，因为索引树中的记录是按顺序排序的，只有最左边的匹配了，才能匹配后面的。<span style="color:red">如果我们想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中从最左边连续的列</span>

=是全值匹配，索引列都是全值匹配时，顺序无所谓，因为索引优化器会优化。

字符串是字符比较，索引varchar这种要用前缀索引。

<span style="color:red">如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到`B+`树索引</span>

因为左边列的值是范围查的，只有左边列相同的情况下，右边列才是排好序的，所以左边范围查出来的，右边不一定是排好序的。

<span style="color:red">只索引字符串值的前缀的策略是我们非常鼓励的，尤其是在字符串类型能存储的字符比较多的时候</span>。

对于`联合索引`order by有个问题需要注意，`ORDER BY`的子句后边的列的顺序也必须按照索引列的顺序给出，如果给出`ORDER BY phone_number, birthday, name`的顺序，那也是用不了`B+`树索引

如果WHERE子句中出现了非排序使用到的索引列，那么排序依然是使用不到索引的

用来排序的多个列不是一个索引里的，这种情况也不能使用索引进行排序

可以引出如下：

怎么查看慢查询

explain

索引优化器

索引的缺点：

空间上：索引也是B+树，所以也占空间

时间上：每次对表中的数据进行增、删、改操作时，都需要去修改各个`B+`树索引。而且我们讲过，`B+`树每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收啥的操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的`B+`树都要进行相关的维护操作，这还能不给性能拖后腿么？



