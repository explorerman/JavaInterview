## 04讲深入浅出索引（上）

总结：

索引的作用：提高数据查询效率
2.常见索引模型：哈希表、有序数组、搜索树
3.哈希表：键 - 值(key - value)。
4.哈希思路：把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置
5.哈希冲突的处理办法：拉链法，rehash法等
6.哈希表适用场景：只有等值查询的场景，KV更适合memcached，redis等nosql引擎
7.有序数组：数据页内部按顺序存储。查询用二分法就可以快速查询，时间复杂度是：O(log(N))
8.有序数组查询效率高，更新效率低
9.有序数组的适用场景：静态存储引擎。
10.二叉搜索树：每个节点的左儿子小于父节点，父节点又小于右儿子
11.二叉搜索树：查询时间复杂度O(log(N))，更新时间复杂度O(log(N))
12.数据库存储大多不适用二叉树，因为树高过高，可以使用N叉树，也就是B和B+树
13.InnoDB中的索引模型：B+Tree
14.索引类型：主键索引、非主键索引
主键索引的叶子节点存的是整行的数据(聚簇索引)，非主键索引的叶子节点内容是主键的值(二级索引)
15.主键索引和普通索引的区别：主键索引只要搜索ID这个B+Tree即可拿到数据。普通索引先搜索索引拿到主键值，再到主键索引树搜索一次(回表)
16.B+树为了维护索引有序，如果新插入的记录所在的页没有满，则直接插入记录，如果刚好满，则开辟一个新页，如果插入的记录是在页的中间，则需要逻辑上挪动位置，**可能会发生页分裂**，会导致性能下降。空间利用率降低大概50%（原本放在一个页的数据， 可能会放到两个页）。如果删除了页面的数据，利用率很低之后，会发生合并，合并的过程是分裂过程的逆过程。
17.从性能和存储空间方面考量，自增主键往往是更合理的选择。

​	从性能分析：因为自增主键的插入数据模式，正符合数据页的递增插入。如果使用业务逻辑的字段做主键，插入时不容易保证有序插入，写数据时成本较高。

​	从存储空间分析：如果用字符串类型的身份证号做主键，每个二级索引的叶子节点占用20个字节，如果用整型做主键，只需要4个字节，长整型bigint需要8个字节。

**显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小，所以使用自增主键往往更合理**

18.适合用业务字段做索引的场景需要：

	1. 只有一个索引
 	2. 该索引必须是唯一索引

这就是典型的**KV**场景。

由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。

这时候我们就要优先考虑上一段提到的“**尽量使用主键查询**”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。

19 为什么要重建索引？

因为索引可能因为删除，或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。

**思考题：**

对于上面例子中的InnoDB表T，如果你要重建索引 k，你的两个SQL语句可以这么写：

```mysql
alter table T drop index k;
alter table T add index(k);
```

如果你要重建主键索引，也可以这么写：

```mysql
alter table T drop primary key;
alter table T add primary key(id);
```

对于上面这两个重建索引的作法，有什么不合适的地方？

二级索引重建应该新建索引再做删除，如果有查询用到这个索引，此时索引已被删除，会导致**业务抖动.**主键重建不能采用drop这种方式去按操作，因为所有数据都是以主键组织的，删了主键后，InnoDB会自己找一个主键组织数据，再次添加主键又会重新组织数据，重建表的次已达二次，我们可以直接Optimiz这个表

重建索引k的做法是合理的，可以达到省空间的目的。但是，重建主键的过程不合理。不论是删除主键还是创建主键，都会将整个表重建。所以连着执行这两个语句的话，第一个语句就白做了。这两个语句，你可以用这个语句代替 ： alter table T engine=InnoDB。

alter table T engine=InnoDB 是用来释放 delete 操作引起的页的空洞,也就是碎片空间 操作时候尽量避免当前表的dml 操作.
表数据很大情况 建议使用 Percona Toolkit 工具来执行


5.6版本的 ICP 对分区表没有作用吧, 子查询也要失去作用, ICP 用于range，ref，eq_ref和ref_or_null访问方法 涉及到
ICP 的使用 查询过程要表的整行才有效？

如果删除，新建主键索引，会同时去修改普通索引对应的主键索引，性能消耗比较大。
删除重建普通索引貌似影响不大，不过要注意在**业务低谷期操作，避免影响业务**。

## 05讲深入浅出索引（下）

###  select * from T where k between 3 and 5，需要执行几次树的搜索操作，会扫描多少行？k上有索引

```mysql
mysql> create table T (
ID int primary key,
k int NOT NULL DEFAULT 0, 
s varchar(16) NOT NULL DEFAULT '',
index k(k))
engine=InnoDB;

insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg');
```

这条SQL查询语句的执行流程：

1. 在k索引树上找到k=3的记录，取得 ID = 300；
2. 再到ID索引树查到ID=300对应的R3；
3. 在k索引树取下一个值k=5，取得ID=500；
4. 再回到ID索引树查到ID=500对应的R4；
5. 在k索引树取下一个值k=6，不满足条件，循环结束。

在这个过程中，**回到主键索引树搜索的过程，我们称为回表**。可以看到，这个查询过程读了k索引树的**3**条记录（步骤1、3和5），回表了两次（步骤2和4）。

在这个例子中，由于查询结果所需要的数据只在主键索引上有，所以不得不回表。

select ID from T where k between 3 and 5可以走覆盖索引

**由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。**

需要注意的是，在引擎内部使用覆盖索引在索引k上其实读了三个记录，R3~R5（对应的索引k上的记录项），但是对于MySQL的Server层来说，它就是找引擎拿到了两条记录，因此MySQL认为扫描行数是2。

### 索引下推

要求检索出表中“名字第一个字是张，而且年龄是10岁的所有男孩”

```mysql
mysql> select * from tuser where name like '张%' and age=10 and ismale=1;
```

在mysql5.6之前，根据最左匹配原则，只能使用“张”索引，然后回表一条条去找age=10的行。

但5.6之后引入了索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

也就是说，在“张”索引树中，先判断age=10的，如果age不等于10，则直接跳过，都不用回表去判断。

### 思考题

实际上主键索引也是可以使用多个字段的。DBA小吕在入职新公司的时候，就发现自己接手维护的库里面，有这么一个表，表结构定义类似这样的：

```mysql
CREATE TABLE `geek` (
  `a` int(11) NOT NULL,
  `b` int(11) NOT NULL,
  `c` int(11) NOT NULL,
  `d` int(11) NOT NULL,
  PRIMARY KEY (`a`,`b`),
  KEY `c` (`c`),
  KEY `ca` (`c`,`a`),
  KEY `cb` (`c`,`b`)
) ENGINE=InnoDB;
```

公司的同事告诉他说，由于历史原因，这个表需要a、b做联合主键，这个小吕理解了。

但是，学过本章内容的小吕又纳闷了，既然主键包含了a、b这两个字段，那意味着单独在字段c上创建一个索引，就已经包含了三个字段了呀，为什么要创建“ca”“cb”这两个索引？

同事告诉他，是因为他们的业务里面有这样的两种语句：

```
select * from geek where c=N order by a limit 1;
select * from geek where c=N order by b limit 1;
```

我给你的问题是，这位同事的解释对吗，为了这两个查询模式，这两个索引是否都是必须的？为什么呢？

结论：ca可以去掉，cb需要保留。

如果c列上重复率很低的情况下,两个索引都可以不用建。因为如果过滤只剩下几条数据,排序也不影响
如果C列重复度比较高,就需要建立(c,b)的联合索引了,来消除排序了。因为在数据量大的情况下,排序是一个非常耗时的操作,
很有可能还需要磁盘临时表来做排序。而且如果没有(c,b)联合索引,limit 1仅仅表示返回给客户端一条数据,没有起到限制扫描行数的作用
ca列上的索引,由于满足最左前缀,不用加。因为c是固定值,那么a列就是有序的.那么这里limit 1就很好限制了只用精准扫描一条数据.
所以有时候如果在where条件建立索引的效率差的情况下,在order by limit这一列建索引也是很好的方案,排好序,在回表,只要过滤出满足条件的limit行,就能及时停止扫描

有几个问题:
1.using where的时候,需要回表,然后把数据传输给server层,server层来过滤数据。那么这些数据是存在server层的哪个地方呢？
2.limit起到限制扫描行数作用并且有using where的时候,limit这个操作时在存储引擎层做的还是在server层做的？
3.ICP是不是做得不太好,感觉很多地方没有用到索引下推,都会显示using index condition

\1. 没有存，就是一个临时内存，读出来马上判断，然后扫描下一行可以复用
\2. Server层。 接上面的逻辑，读完以后顺便判断一下够不够limit 的数了，够就结束循环
\3. 嗯，你很细心，其实它表示的是“可以下推”，实际上是“可以，但没有”😄

### 怎么让mysql的myisam支持事务

用lock table 来实现，但是这样只能实现串行化隔离级别，其它隔离都实现不了。但是因为mysiam不支持崩溃恢复，所以即使用lock table硬实现，也是问题多多：

ACID里面， 原子性和持久性做不到；
隔离性只能实现基本用不上的串行化；
一致性在正常运行的时候依赖于串行化，在异常崩溃的时候也不能保证。

这样实现的事务不要也罢。

## 09讲普通索引和唯一性索引，如何选择？

### 普通索引和唯一索引怎么选择

对于查询过程来说：
a、普通索引，查到满足条件的第一个记录后，继续查找下一个记录，知道第一个不满足条件的记录
b、唯一索引，由于索引唯一性，查到第一个满足条件的记录后，停止检索
但是，两者的性能差距微乎其微。因为InnoDB根据数据页来读写的。

对于更新过程来说：
概念：change buffer
当需要更新一个数据页，如果数据页在内存中就直接更新，如果不在内存中，在不影响数据一致性的前提下，InnoDB会将这些更新操作缓存在change buffer中。下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中的与这个页有关的操作。

change buffer是可以持久化的数据。在内存中有拷贝，也会被写入到磁盘上

**purge**:将change buffer中的操作应用到原数据页上，得到最新结果的过程，成为purge
访问这个数据页会触发purge，系统有后台线程定期purge，在数据库正常关闭的过程中，也会执行purge

**唯一索引的更新不能使用change buffer**

change buffer用的是buffer pool里的内存，change buffer的大小，可以通过参数innodb_change_buffer_max_size来动态设置。这个参数设置为50的时候，表示change buffer的大小最多只能占用buffer pool的50%。

将数据从磁盘读入内存涉及随机IO的访问，是数据库里面成本最高的操作之一。
change buffer 因为减少了随机磁盘访问，所以对更新性能的提升很明显。

change buffer使用场景
在一个数据页做purge之前，change buffer记录的变更越多，收益就越大。
对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。

反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在change buffer,但之后由于马上要访问这个数据页，会立即触发purge过程。
这样随机访问IO的次数不会减少，反而增加了change buffer的维护代价。所以，对于这种业务模式来说，change buffer反而起到了副作用。

索引的选择和实践：
尽可能使用普通索引。
redo log主要节省的是随机写磁盘的IO消耗(转成顺序写)，而change buffer主要节省的则是随机读磁盘的IO消耗。

思考题：
change buffer不会丢失，因为change buffer是可以持久化的数据，在磁盘上占据了系统表空间ibdata，对应的内部系统表名为SYS_IBUF_TABLE。因此在异常关机的时候，不会丢失。

不会丢失还有redolog的功劳

## 10讲mysql为什么有时候会选错索引



## 11讲怎么给字符串字段加索引

## 15讲：日志和索引相关问题答疑

## 18讲 为什么这些SQL语句逻辑相同，性能却差异巨大（索引失效的几种方式）

1. where中有函数运算
2. 两个字段的类型不一样，mysql是字符串转int进行计算
3. 编码格式不一样，utf-8和GBK的表之间联合查找，不走索引