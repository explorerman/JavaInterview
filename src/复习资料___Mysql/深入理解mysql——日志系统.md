一个查询语句的执行过程会经过：连接器，分析器，优化器，执行器等过程，最后到达存储引擎。

与查询流程不一样的是，更新流程还会涉及日志系统最重要的两个模块：redo log（重做日志）, binlog（归档日志）

重做日志：redo log

在mysql中，不可能每次更新操作都更新磁盘，因为如果每次更新操作都写磁盘，磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本，查找成本都很高，所以设计了redo log

类似于酒店掌柜粉板的故事：粉板和账本配合的过程，跟mysql里的WAL（write-ahead logging）技术一样，**关键点是先写日志，在写磁盘，等不忙的时候或者日志满了的时候，写磁盘**

具体来说：当一条记录需要更新的时候，Innodb引擎会先把记录写到redo log(粉板）里面，并更新内存，这个时候更新就算完成了，同事，innodb引擎会在适当的时候，将这个操作更新到磁盘里面，而这个更新往往是在系统比较闲的时候做，如果日志非常多，redo log写满了，不得不停下来写磁盘

redo log是固定大小的，可以循环写，write pos和checkpoint之间的部分是空着的部分，write pos是当前记录的位置，一边写一边后移，checkpoint是当前要擦除的位置，也是往后移动并循环的，**擦除记录之前要把记录更新到数据文件**，当write log追上checkpoint的时候，表示“粉板满了”，这时候不能在执行新的更新，需要停下来先擦掉一些记录，把checkpoint推进一下。

![image-20200623161117832](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3mysql%E2%80%94%E2%80%94%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F.assets/image-20200623161117832.png)

有了redo log，innodb可以保证即使数据库发生异常重启，之前提交的记录也不会丢失，这个能力称为:**crash-safe**也就是崩溃恢复

归档日志：binlog

mysql整体看，其实就是：server层（做的是mysql功能层面的事情）和引擎层（负责存储相关）

redo log是innodb特有的日志，server层的日志就是binlog(归档日志)

binlog和redolog的不同：

- redolog是innodb的，binlog是mysqlserver层的，所有引擎都可以用
- redo log是物理日志，记录的是”在某个数据页做了什么修改“；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如:给ID=2这一行的c字段加1
- redolog是循环写的，空间固定会用完，binlog是可以追加写的。“追加写”是指binlog文件写到一定大小后切换到下一个，并不会覆盖以前的日志。

**Binlog有两种模式，statement 格式的话是记sql语句， row格式会记录行的内容，记两条，更新前和更新后都有。**一般采用row，因为遇到时间，从库可能会出现不一致的情况，但是row更新前后都有，会导致日志变大最后2个参数，保证事务成功，日志必须落盘，这样，数据库crash后，就不会丢失某个事务的数据了

执行器和innodb引擎在执行这个简单的update语句是的内部流程

1. 执行器先找引擎取ID=2这 一行，ID是主键，引擎直接用树搜索找到这一行，如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器，否则，需要先从磁盘读入内存，然后再返回

2. 执行器拿到引擎给的行数据，把这个值加1，比如原来是N，现在就是N+1，得到新的一行数据，在调用引擎接口写入这行新数据

3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态，然后告诉执行器执行完成了，随时可以提交事务

4. 执行器生成这个操作的binlog，并把binlog写入磁盘

5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。

   **图中浅色框表示是在InnoDB内部执行的，深色框表示是在执行器中执行的。**

![img](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3mysql%E2%80%94%E2%80%94%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F.assets/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png)

**两段式提交** 如何让数据库恢复到半个月内任意一秒的状态

两段式提交是为了让两份日志之间的逻辑一致，binlog会记录所有的逻辑操作，并且是采用“追加写”的形式，如果要求恢复半个月内的数据，那么备份系统中一定会保存最近半个月的所有binlog，同时系统会定期做整库备份

这两的**定期**取决于系统的重要性，可以是一天一备，也可以是一周一备。

当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：

- 首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到**临时库**；
- 然后，从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。

这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。

为什么日志需要“两阶段提交”？利用反证法

由于binlog和redo log是两个独立的逻辑，如果不用两阶段提交，那么就是先写完redo log在写binlog，或者反过来的顺序执行。

假设当前ID=2的行，字段c的值是0，再假设执行update语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash，会出现什么情况呢？

1. 先写redo log后写binlog，假设在redo log写完，binlog还没有写完的时候，mysql进程异常重启，redo log写完之后，系统即使奔溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1

   但由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句，因此，之后备份日志的时候，存起来的binlog里面没有这条语句

   然后如果需要用这个binlog来恢复临时表的话，由于这个语句的binlog丢失，这个临时表就会少更新这一次更新，恢复出来的这一行c的值是0，与原库的值不一样。

2. 先写binlog后写redolog，如果在binlog写完后crash，由于redo log还没有写，奔溃恢复后这个事务无效，所以这行c的值是0，但binlog里面记录了“把c从0改成1”这个日志，所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同

**所以如果不使用两段式提交，那么数据库的状态就有可能和它的日志恢复出来的库的状态不一致。**

不只是误操作后需要用这个过程来恢复数据。当你需要**扩容**的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用**全量备份加上应用binlog来实现的**，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。

**简单说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。**

总结：

- redo log用于保证crash-safe能力。**innodb_flush_log_at_trx_commit这个参数设置成1的时候**，表示每次事务的redo log都直接持久化到磁盘。这个参数我建议你设置成1，这样可以保证MySQL异常重启之后数据不丢失。
- **sync_binlog**这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。这个参数我也建议你设置成1，这样可以保证MySQL异常重启之后binlog不丢失。

**两阶段提交是跨系统维持数据逻辑一致性时常用的一个方案**

课后题：定期全量备份的周期是选择：一周一备份，还是一天一备份？

首先，是恢复数据丢失的时间，既然需要恢复，肯定是数据丢失了。如果一天一备份的话，只要找到这天的全备，加入这天某段时间的binlog来恢复，如果一周一备份，假设是周一，而你要恢复的数据是周日某个时间点，那就，需要全备+周一到周日某个时间点的全部binlog用来恢复，时间相比前者需要增加很多；看业务能忍受的程度
其次，是数据库丢失，如果一周一备份的话，需要确保整个一周的binlog都完好无损，否则将无法恢复；而一天一备，只要保证这天的binlog都完好无损；当然这个可以通过校验，或者冗余等技术来实现，相比之下，上面那点更重要

所以对于系统恢复速度很敏感的系统，最好使用一天一备，甚至有可能一个小时一备份

总结：两段式提交过程

1 prepare阶段 2 写binlog 3 commit
当在2之前崩溃时
重启恢复：后发现没有commit，回滚。备份恢复：没有binlog 。
一致
当在3之前崩溃
重启恢复：虽没有commit，但满足prepare和binlog完整，所以重启后会自动commit。备份：有binlog. 一致