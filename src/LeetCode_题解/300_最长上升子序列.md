300——最长上升子序列

给定一个无序的整数数组，找到其中最长上升子序列的长度。

示例:

输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
说明:

可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
你算法的时间复杂度应该为 O(n2) 。
进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?



题解：这道题是dp常考类型之一，典型的动态规划

```java
public int lengthOfLIS(int[] nums) {
	int len = nums.length;
  int[] dp = new int[len];
  //因为每个位置的元素，至少都是自己的上升子序列，所以初始化为1
  Arrays.fill(nums,1);
  //找出dp最长的上升子序列
  int res = 0;
  //外层循环用于遍历数组
  for(int i = 0; i < len; i++){
    //内层循环用于遍历当前值之前的元素
    for(int j = 0; j < i; j++){
      //如果有比位置元素大的，则更新dp[]
      if(nums[j] < nums[i]){
        //位置的值，只与自身和比它值大的j位置的值+1相比较，取最大值
        dp[i] = Math.max(dp[i], dp[j] + 1);
      }
    }
    //更新最大值
    res = Math.max(res, dp[i]);
  }
  return res;
    }
```

