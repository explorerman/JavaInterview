ThreadPoolExecutor中的execute和submit

线程池的话，线程池内部某个子线程异常，不会终止线程池(submit内部有异常捕获，控制台不会跑出异常，executor控制台会跑出异常)；线程池模式时，线程池daemon同单个线程
exector在addwork中，新起线程，runwork中的finally会抛异常、

[submit和execute的区别](https://www.cnblogs.com/liuchuanfeng/p/6956014.html)

[Java线程池异常处理方案](https://www.jianshu.com/p/30e488f4e021)

[一个线程池中的线程异常了，线程池会怎么处理这个线程](https://www.jianshu.com/p/40e8f4ccc796)

### 为什么要使用线程池

1. 减少创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。
2. 可以根据系统的承受能力，调整线程池中工作线程的数目，放置因为消耗过多的内存，而把服务器累趴下

### 核心线程池ThreadPoolExecutor内部参数

1. corePoolSize：核心线程的数量
2. maximumPoolSize：线程池的最大数量
3. keepAliveTime：线程的存活时间
4. timeUnit: 线程的存活时间的单位
5. workQueue：任务队列，被提交但尚未被执行的任务，阻塞队列的类型
6. threadFactory：线程工厂，用于创建线程，一般用默认的即可。
7. handler：如果整个线程池都满的话，需要采用 的拒绝策略

### 线程池的工作流程

1. 如果有的新的任务过来，先判断核心线程池的线程是不是都满了，如果没有满的话直接新建一个线程进行执行任务，如果核心线程池满的话，就进入下一步。
2. 此时会先判断阻塞队列是不是满了（这里选择的阻塞队列十分重要，如果选择的是无界队列的话，就没有**最大线程池**这一说法，也就是这个参数就没有意义），如果阻塞队列没有满的话，就把提交过来的任务包装成一个队列的节点，存在队列中，如果阻塞队列满的话，就进入下一步
3. 到这里就开始判断线程池的最大数量是不是全部都在工作，如果有空闲的话，就直接通过线程工厂去新建一个线程去执行任务，如果所有的线程都在工作状态的话，就去执行下一步
4. 到了这一步，拒绝策略就开始起作用了，根据我们定义的拒绝策略去进行执行，如此反复的从头开始。

### 线程池的拒绝策略

1. ThreadPoolExecutor.AbortPolicy:直接抛出异常，丢弃任务。（jdk默认策略，队列满并线程满时直接拒绝添加新任务，并抛出RejectedExecutionException异常
2. DiscardPolicy：这种策略和AbortPolicy几乎一样，也是丢弃任务，只不过他不抛出异常
3. DiscardOldestPolicy：这种其实是在当线程池没有关闭的前提下，会先去丢弃掉缓存在队列中的最早的任务
4. CallerRunsPolicy：由调用线程（提交任务的线程）处理该任务,此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。

### **如果现在阻塞队列中的任务满了，而且这任务又必须执行，该怎么办？**

问这类型问题，考虑线程池的拒绝策略

可以实现RejectedExecutionHandler接口来进行自定义拒绝策略来完成这个任务

![](http://assets.processon.com/chart_image/5ee71c54e0b34d4dba3bd6f3.png)

### 线程池的线程数量怎么确定

1. 一般来说，如果是CPU密集型应用，则线程池大小设置为N+1。
2. 一般来说，如果是IO密集型应用，则线程池大小设置为2N+1。
3. 在IO优化中，线程等待时间所占比例越高，需要越多线程，线程CPU时间所占比例越高，需要越少线程。这样的估算公式可能更适合：最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目