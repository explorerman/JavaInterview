

## InnoDB的buffer poll

buffer poll为了解决从磁盘读写慢，使用buffer poll在内存中申请了一块连续的空间作为缓存



[mysql5.6升级到5.7](https://blog.csdn.net/u010010725/article/details/70170231)

1. 索引

## 表结构设计

三范式：

1.  1NF是对属性的原子性约束，要求属性具有原子性，不可再分解； 
2.  2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性； 
3.  3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。。 

范式化设计优缺点:

**优点:**

可以尽量得减少数据冗余，使得更新快，体积小

缺点:对于查询需要多个表进行关联，减少写得效率增加读得效率，更难进行索引优化

**反范式化:**

优点:可以减少表得关联，可以更好得进行索引优化

缺点:数据冗余以及数据异常，数据得修改需要更多的成本

重构oa项目表结构设计：取号加了乐观锁（以前业务有重号的问题），

1. 基本原则：根据业务灵活拆分：dm表，cs表，业务表单：将所有的表单进行拆分。

重构交换表结构做的两件事：

1. 业务表的拆分，根据范式和业务进行调整，以前的业务表冗余性要不很大，要不很小，我做的改进：业务表基本由三部分构成：表单数据，表单关联项（正文，附件，意见等，都存主键），流程设置

2. 根据业务场景合适的加索引：

1. 场景1：打开一个文，where条件第一个都是主键，所以不需要加索引，直接走聚簇索引。
2. 场景2：查询已发送公文的列表：where条件一般为当前登录人，链表一般只需要展示文的名称，环节，接收单位等，所以建了联合索引。涉及的多表在业务中做关联。

业务表：存三部分：表单数据，正文/附件id,意见类（意见，备注等）配置（打开标准，删除标准，操作人id，时间）


## sql优化

两个重构项目做的优化：表结构调整（都设为非空，控制字段长度），索引，代码层面都改为单表，代码中合并数据。

范式，索引（B+树）得熟

隔离级别，ACID事务等次之

redo,undo日志。

[ 向mysql插入100w条数据，存储过程 ](https://cloud.tencent.com/developer/article/1534007)

[mysql使用存储过程插入千万级数据如何提升效率](https://blog.csdn.net/youcheng_ge/article/details/77728189)

[mysql中为什么不要使用存储过程](https://blog.csdn.net/aoerqileng/article/details/79731713)